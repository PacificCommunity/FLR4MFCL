

#' generate
#'
#' generates modified input files for mfcl.
#' Currently works when projection years are scaled by a single reference year.
#' Use of mulitple reference years eg.2008:2012 may cause problems.
#'
#' @param x:    Either an object of class MFCLFrq or of class MFCLPar.
#' @param y:    Eitehr an object of class MFCLprojCtrl or MFCLPar as generated by makepar.
#'
#' @param ... Additional argument list that might not ever
#'  be used.
#'
#' @return Modified input file in accordance with projection settings.
#' 
#' @seealso \code{\link{projCtrl}} 
#' 
#' @export
#' @docType methods
#' @rdname generate-methods
#'
#' @examples
#' generate(MFCLFrq(), MFCLprojControl())
#' generate(MFCLPar(), MFCLPar())

setGeneric('generate', function(x, y, ...) standardGeneric('generate')) 



#' @rdname generate-methods
#' @aliases generate

setMethod("generate", signature(x="MFCLFrq", y="MFCLprojControl"), 
         function(x, y, ...){
            
            ctrl     <- y
            proj.yrs <- seq(range(x)['maxyear']+1, range(x)['maxyear']+nyears(ctrl))
            qtrs     <- sort(unique(freq(x)$month))
            
            week   <- rev(freq(x)$week)[1]
            if(!all(freq(x)$week==week))
              warning("Differences in week not accounted for in projection frq")
            
            if(length(caeff(ctrl))>1 & length(caeff(ctrl))!=n_fisheries(x))
              stop("Error: caeff values do not match number of fisheries")
            if(length(scaler(ctrl))>1 & length(scaler(ctrl))!=n_fisheries(x))
              stop("Error: scaler values do not match number of fisheries")
            
            sc_df <- data.frame(fishery=1:n_fisheries(x), caeff  = caeff(ctrl), scaler = scaler(ctrl))
            
            avdata <- freq(x)[is.element(freq(x)$year, avyrs(ctrl)) & is.na(freq(x)$length) & is.na(freq(x)$weight) ,]
            avdata <- rbind(avdata, freq(x)[is.element(freq(x)$year, avyrs(ctrl)) & freq(x)$length %in% lf_range(x)['LFFirst'] ,],
                                    freq(x)[is.element(freq(x)$year, avyrs(ctrl)) & freq(x)$weight %in% lf_range(x)['WFFirst'] ,])
            
            avdata$catch[avdata$catch == -1] <- NA
            avdata$effort[avdata$effort == -1] <- NA
            
            avcatch  <- sweep(tapply(avdata$catch,  list(avdata$month, avdata$fishery), sum), 2, sc_df$scaler, "*")
            aveffort <- sweep(tapply(avdata$effort, list(avdata$month, avdata$fishery), sum), 2, sc_df$scaler, "*")
            
            projdat  <- data.frame(year    = rep(proj.yrs, each=(n_fisheries(x)*length(qtrs))),
                                   month   = qtrs,
                                   week    = week,
                                   fishery = rep(rep(1:n_fisheries(x),each=length(qtrs)), nyears(ctrl)),
                                   catch   = c(avcatch), 
                                   effort  = c(aveffort),
                                   penalty = -1.0, length=NA, weight=NA, freq=-1)
            
            # remove records with missing values from projection years
            projdat2 <- rbind(projdat[is.element(projdat$fishery, sc_df[sc_df$caeff==1, 'fishery']) & !is.na(projdat$catch),],
                              projdat[is.element(projdat$fishery, sc_df[sc_df$caeff==2, 'fishery']) & !is.na(projdat$effort),])
            
            # set the penalty to 1.0 for those fisheries with standardised CPUE -- maybe ?
            std.fish <- seq(1:n_fisheries(x))[tapply(freq(x)$penalty, freq(x)$fishery, mean)>0]
            projdat2$penalty[is.element(projdat2$fishery, std.fish)] <- 1.0
            
            # set catch/effort to -1 for fisheries projected on effort/catch
            projdat2[is.element(projdat2$fishery, sc_df[sc_df$caeff==1, 'fishery']),'effort'] <- -1
            projdat2[is.element(projdat2$fishery, sc_df[sc_df$caeff==2, 'fishery']),'catch'] <- -1
            
            freq(x) <- rbind(freq(x), projdat2)
            
            data_flags(x)[2,] <- as.numeric(max(avyrs(ctrl)))+1
            data_flags(x)[3,] <- as.numeric(qtrs[1])
            lf_range(x)['Datasets'] <- lf_range(x)['Datasets']+nrow(projdat2)
            slot(x,'range')['maxyear']     <- max(freq(x)$year)
            
            return(x)
          })

    






#' @rdname generate-methods
#' @aliases generate

setMethod("generate", signature(x="MFCLPar", y="MFCLPar"), 
          function(x, y, ...){
     
     proj.yrs <- dimnames(rel_rec(y))[[2]][!is.element(dimnames(rel_rec(y))[[2]], dimnames(rel_rec(x))[[2]])]
       
     rep_rate_dev_coffs(x) <- rep_rate_dev_coffs(y)
     fm_level_devs(x)      <- fm_level_devs(y)
     
     q_dev_coffs(x)        <- q_dev_coffs(y)
     sel_dev_coffs(x)      <- sel_dev_coffs(y)
     sel_dev_coffs2(x)     <- sel_dev_coffs2(y)
     growth_devs_cohort(x) <- growth_devs_cohort(y)
     unused(x)             <- unused(y)
     lagrangian(x)         <- lagrangian(y)
     
     eff_dev_coff_incs     <- unlist(lapply(effort_dev_coffs(y),length)) - unlist(lapply(effort_dev_coffs(x),length))
     effort_dev_coffs(x)   <- lapply(1:dimensions(x)["fisheries"], function(g) c(effort_dev_coffs(x)[[g]], rep(0, eff_dev_coff_incs[g])))
     
     catch_dev_coffs(x)    <- lapply(1:dimensions(x)["fisheries"], function(g) c(catch_dev_coffs(x)[[g]], 
                                                                                 rep(0, length(rep_rate_dev_coffs(y)[[g]])-length(catch_dev_coffs(x)[[g]]))))
     
     region_rec_var(x)     <- window(region_rec_var(x), start=range(x)['minyear'], end=range(y)['maxyear'])
     region_rec_var(x)[is.na(region_rec_var(x))] <- 0
     
     rel_rec(x) <- window(rel_rec(x), start=range(x)['minyear'], end=range(y)['maxyear'])
     rel_rec(x)[,proj.yrs] <- rel_rec(y)[,proj.yrs] 
     
     dimensions(x)         <- dimensions(y)
     range(x)              <- range(y)
     
     return(x)
            
})



